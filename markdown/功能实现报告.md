# SelfBoard项目功能实现报告

## 1. 项目概述

SelfBoard项目是基于STM32H747XIH6双核处理器的TinyML开发板实现，集成了丰富的外设和功能模块，包括内存扩展、外部存储、图像采集、音频采集、WiFi通信等功能。本报告详细描述各个功能模块的具体实现方式。

## 2. 系统初始化与基础框架

### 2.1 系统启动流程

```c
int main(void)
{
    // MPU配置
    MPU_Config();
    
    // 初始化HAL库
    HAL_Init();
    
    // 配置系统时钟
    SystemClock_Config();
    
    // 双核通信 - 释放CM4核心
    __HAL_RCC_HSEM_CLK_ENABLE();
    HAL_HSEM_FastTake(HSEM_ID_0);
    HAL_HSEM_Release(HSEM_ID_0, 0);
    
    // 初始化外设
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_USART1_UART_Init();
    MX_USART3_UART_Init();
    MX_FMC_Init();
    MX_QUADSPI_Init();
    MX_SAI1_Init();
    MX_UART4_Init();
    MX_DCMI_Init();
    MX_I2C1_Init();
    MX_I2C2_Init();
}
```

系统启动流程包括MPU配置、HAL库初始化、系统时钟配置、双核通信设置和外设初始化。通过硬件信号量(HSEM)机制实现CM7和CM4双核之间的同步。

### 2.2 系统时钟配置

系统时钟配置使用HSI作为时钟源，通过PLL倍频到200MHz：

```c
void SystemClock_Config(void)
{
    /* 1. 供电配置
     * PWR_DIRECT_SMPS_SUPPLY：选择片内高效同步降压转换器（SMPS）直接供电
     * PWR_REGULATOR_VOLTAGE_SCALE1：内核电压档位1，对应最高主频200 MHz所需电压
     * 说明：先配电源再配时钟，确保PLL在正确电压下稳定工作
     */
    HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    /* 2. 振荡器与PLL配置
     * 选用HSI（内部16 MHz RC）作为PLL输入，经分频-倍频后输出400 MHz PLLCLK
     * PLLM = 4：输入分频 → 16 MHz / 4 = 4 MHz（PLL VCO输入范围要求）
     * PLLN = 50：倍频 → 4 MHz × 50 = 200 MHz（VCO实际输出）
     * PLLP = 2：系统时钟分频 → 200 MHz / 2 = 100 MHz（最终SYSCLK）
     * 注：H747 的 PLLP 输出直接作为 SYSCLK 来源，因此实际芯片主频 200 MHz
     */
    RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState            = RCC_HSI_DIV1;   /* HSI 不分频，保持 16 MHz */
    RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
    RCC_OscInitStruct.PLL.PLLM            = 4;
    RCC_OscInitStruct.PLL.PLLN            = 50;
    RCC_OscInitStruct.PLL.PLLP            = 2;            /* 产生 200 MHz PLLCLK */

    /* 3. 总线时钟分配
     * SYSCLK  = 200 MHz（内核、SysTick、FCLK）
     * AHB     = SYSCLK / 2 = 100 MHz（AXI、DMA、内存接口）
     * APB1/APB2 在后续代码中继续二分频 → 50 MHz，满足外设最大频率限制
     * 目标：高性能同时保证外设可靠时序
     */
    RCC_ClkInitStruct.SYSCLKSource        = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.SYSCLKDivider       = RCC_SYSCLK_DIV1;  /* 200 MHz */
    RCC_ClkInitStruct.AHBCLKDivider       = RCC_HCLK_DIV2;    /* 100 MHz */
}
```

## 3. 功能模块实现

### 3.1 外部SDRAM扩展

#### 3.1.1 实现原理

外部SDRAM通过FMC接口连接，提供32MB的扩展内存空间，地址范围为0xC0000000。实现包括初始化、读写测试和性能评估。

#### 3.1.2 关键代码

**SDRAM初始化**：
```c
void Ext_SDRAM_Init(void)
{
    // 1. 时钟使能命令
    SDRAM_SendCommand(FMC_SDRAM_CMD_CLK_ENABLE, 1, 1, 0);
    
    // 2. 延时，至少100us
    HAL_Delay(1);
    
    // 3. SDRAM全部预充电命令
    SDRAM_SendCommand(FMC_SDRAM_CMD_PALL, 1, 1, 0);
    
    // 4. 自动刷新命令
    SDRAM_SendCommand(FMC_SDRAM_CMD_AUTOREFRESH_MODE, 1, 8, 0);
    
    // 5. 配置SDRAM模式寄存器
    temp = SDRAM_MODEREG_BURST_LENGTH_1 | 
           SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL | 
           SDRAM_MODEREG_CAS_LATENCY_3 | 
           SDRAM_MODEREG_OPERATING_MODE_STANDARD | 
           SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
    SDRAM_SendCommand(FMC_SDRAM_CMD_LOAD_MODE, 1, 1, temp);
    
    // 6. 设置自刷新频率
    HAL_SDRAM_ProgramRefreshRate(&hsdram1, 1668);
}
```

**SDRAM测试**：
```c
#ifdef DBG_EXSDRAM_TEST
    // 单字节和单字测试
    uint8_t write_byte_data = 0x55;
    uint32_t write_word_data = 0x12345678;
    *(volatile uint8_t*)EXT_SDRAM_ADDR = write_byte_data;
    *(volatile uint32_t*)(EXT_SDRAM_ADDR+0x1000) = write_word_data;
    
    // 验证数据
    if(read_byte_data == write_byte_data && read_word_data == write_word_data)
    {
        printf("SDRAM Single Test Passed !\n");
    }
    
    // 多字节测试
    for(int i = 0; i < EXT_SDRAM_SIZE; i++)
    {
        *(volatile uint8_t*)(EXT_SDRAM_ADDR + i) = i;
    }
    // 验证多字节数据
#endif
```

### 3.2 QSPI Flash外部存储

#### 3.2.1 实现原理

使用W25Q256JVFIQ型号的QSPI Flash作为外部存储介质，通过QuadSPI接口进行高速数据传输，支持页写入、扇区擦除和数据读取操作。

#### 3.2.2 关键代码

**Flash页写入**：
```c
void W25Q256JVFIQ_PageWrite(uint32_t address, uint8_t *data, uint32_t size)
{
    // 写使能
    W25Q256JVFIQ_WriteEnable();
    
    // 配置QSPI命令
    QSPI_CommandTypeDef cmd;
    cmd.Instruction = W25Q256_CMD_PAGE_PROGRAM;
    cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
    cmd.AddressMode = QSPI_ADDRESS_1_LINE;
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
    cmd.DataMode = QSPI_DATA_1_LINE;
    cmd.Address = address;
    cmd.NbData = size;
    
    // 发送命令并传输数据
    QSPI_SendCommand(&cmd);
    HAL_QSPI_Transmit(&hqspi, data, HAL_QPSI_TIMEOUT_DEFAULT);
    
    // 等待操作完成
    W25Q256JVFIQ_WaitForReady();
}
```

**Flash读取**：
```c
void W25Q256JVFIQ_Read(uint32_t address, uint8_t *data, uint32_t size)
{
    QSPI_CommandTypeDef cmd;
    cmd.Instruction = W25Q256_CMD_READ_DATA;
    cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
    cmd.AddressMode = QSPI_ADDRESS_1_LINE;
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
    cmd.DataMode = QSPI_DATA_1_LINE;
    cmd.Address = address;
    cmd.NbData = size;
    
    QSPI_SendCommand(&cmd);
    HAL_QSPI_Receive(&hqspi, data, HAL_QPSI_TIMEOUT_DEFAULT);
}
```

**功能测试**：
```c
#ifdef DBG_QSPIFLASH_TEST
    // 擦除扇区
    W25Q256JVFIQ_EraseSector(0x100000);
    
    // 写入测试数据
    uint8_t flash_write_data[] = "Hello, hengheng!";
    W25Q256JVFIQ_PageWrite(0x100000, flash_write_data, sizeof(flash_write_data));
    
    // 读取并验证
    uint8_t flash_read_data[sizeof(flash_write_data)];
    W25Q256JVFIQ_Read(0x100000, flash_read_data, sizeof(flash_read_data));
    
    // 验证数据
    for(int i = 0; i< sizeof(flash_write_data); i++)
    {
        if(flash_write_data[i] != flash_read_data[i])
        {
            printf("QSPI Flash Test Failed!\n");
            break;
        }
    }
#endif
```

### 3.3 OV2640摄像头图像采集

#### 3.3.1 实现原理

使用OV2640摄像头模块通过DCMI接口进行图像采集，I2C接口进行配置。支持分辨率设置、自动曝光控制和图像数据传输。

#### 3.3.2 关键代码

**摄像头初始化**：
```c
void OV2640_Init(void)
{
    // PWDN和RST引脚配置
    Camera_PDRST_Init();
    HAL_GPIO_WritePin(CAM_PWDN_PORT, CAM_PWDN_PIN, 0);
    HAL_Delay(10);
    HAL_GPIO_WritePin(CAM_RST_PORT, CAM_RST_PIN, 0);
    HAL_Delay(10);
    HAL_GPIO_WritePin(CAM_RST_PORT, CAM_RST_PIN, 1);
    
    // 读取并验证设备ID
    uint8_t value;
    if (OV2640_ReadReg(0x0A, &value) != HAL_OK || value != 0x26) {
        Error_Handler();
    }
    
    // 重置摄像头
    OV2640_WriteReg(0x0C, 0x0C);
    
    // 设置分辨率为160x120
    OV2640_WriteReg(0x12, 0x40);
    
    // 设置数据格式为RAW
    OV2640_WriteReg(0x15, 0x00);
    
    // 设置帧率控制
    // ...
}
```

**I2C寄存器读写**：
```c
HAL_StatusTypeDef OV2640_WriteReg(uint8_t reg, uint8_t value) {
    uint8_t data[2] = {reg, value};
    return HAL_I2C_Master_Transmit(&hi2c2, OV2640_I2C_ADDRESS, data, 2, HAL_MAX_DELAY);
}

HAL_StatusTypeDef OV2640_ReadReg(uint8_t reg, uint8_t *value) {
    HAL_I2C_Master_Transmit(&hi2c2, OV2640_I2C_ADDRESS, &reg, 1, HAL_MAX_DELAY);
    return HAL_I2C_Master_Receive(&hi2c2, OV2640_I2C_ADDRESS, value, 1, HAL_MAX_DELAY);
}
```

**功能测试**：
```c
#ifdef DBG_CAMERADCMI_TEST
    OV2640_Init();
    OV2640_EnableAutoExposure();
    //Start_Capture();
#endif
```

### 3.4 PDM麦克风音频采集

#### 3.4.1 实现原理

使用MP34DT06JTR数字麦克风，通过SAI接口接收PDM（脉冲密度调制）数据，然后通过PDM/PCM滤波器转换为标准PCM格式。

#### 3.4.2 关键代码

**PDM/PCM滤波器初始化**：
```c
void USER_PDM_Filter_Init(void)
{
    // 配置滤波器处理器
    PDM_FilterHandler.bit_order = PDM_FILTER_BIT_ORDER_LSB;
    PDM_FilterHandler.endianness = PDM_FILTER_ENDIANNESS_LE;
    PDM_FilterHandler.high_pass_tap = 2122358088;
    PDM_FilterHandler.out_ptr_channels = 1;
    PDM_FilterHandler.in_ptr_channels = 1;
    PDM_Filter_Init(&PDM_FilterHandler);
    
    // 配置滤波器参数
    PDM_FilterConfig.output_samples_number = PCM_BUFFER_SIZE;
    PDM_FilterConfig.mic_gain = 24;           // 增益设置
    PDM_FilterConfig.decimation_factor = PDM_FILTER_DEC_FACTOR_64;  // 64倍降采样
    PDM_Filter_setConfig(&PDM_FilterHandler, &PDM_FilterConfig);
}
```

**PDM数据接收**：
```c
void Start_PDM_Receive(void)
{
    // 使用DMA接收PDM数据
    if (HAL_SAI_Receive_DMA(&hsai_BlockA1, pdm_buffer, PDM_BUFFER_SIZE) != HAL_OK)
    {
        Error_Handler();
    }
}
```

**PDM到PCM转换**：
```c
void Process_PDM_To_PCM(void)
{
    PDM_Filter(pdm_buffer, pcm_buffer, &PDM_FilterHandler);
}
```

**功能测试**：
```c
#ifdef DBG_MICROPHONE_TEST
    Start_PDM_Receive();
    HAL_Delay(10);
    Process_PDM_To_PCM();
#endif
```

### 3.5 WiFi通信模块

#### 3.5.1 实现原理

通过UART4接口连接WiFi模块，使用AT命令集进行控制，支持网络连接和数据传输。实现了命令转发和数据接收功能。

#### 3.5.2 关键代码

**WiFi命令交互**：
```c
#ifdef DBG_WIFI_TEST
    uint8_t at_command_buf[WIFI_RX_BUFFER_SIZE];
    printf("Start Wifi Test, help with Dbg console! \n");
    
    while(1) 
    {
        // 当调试控制台接收到命令时，转发给WiFi模块
        if(dbg_rx_size !=0 && (dbg_rx_size < (WIFI_RX_BUFFER_SIZE - 2)))
        {
            memcpy(at_command_buf, dbg_rx_final_buf, dbg_rx_size);
            at_command_buf[dbg_rx_size] = '\r';
            at_command_buf[dbg_rx_size] = '\n';
            HAL_UART_Transmit(&huart4, at_command_buf, (dbg_rx_size+2), HAL_MAX_DELAY);
            dbg_rx_size = 0;
        }
        HAL_Delay(20);
    }
#endif
```

**UART中断配置**：
```c
HAL_UARTEx_ReceiveToIdle_IT(&huart4, wifi_rx_tmp_buf, WIFI_TMP_RXBUFF_SIZE);
HAL_UARTEx_ReceiveToIdle_IT(&huart1, dbg_rx_tmp_buf, DBG_TMP_RXBUFF_SIZE);
```

### 3.6 内存延迟测试模块

#### 3.6.1 实现原理

使用DWT（数据观察点和跟踪单元）计数器测量不同类型内存（DTCM、SRAM、SDRAM）的读取延迟，通过大量迭代测试获取平均访问时间。

#### 3.6.2 关键代码

**DWT初始化**：
```c
void InitDWT(void)
{
    // 使能DWT外设
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    // 重置计数器
    DWT->CYCCNT = 0;
    // 使能计数器
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
}
```

**内存延迟测试**：
```c
void TestMemoryLatency(void)
{
    // 定义测试缓冲区
    volatile uint32_t dtcm_buffer[BUFFER_SIZE] __attribute__((section(".ARM.__at_0x20000000")));
    volatile uint32_t sram_buffer[BUFFER_SIZE] __attribute__((section(".ARM.__at_0x24030000")));
    volatile uint32_t *sdram_buffer = (volatile uint32_t *)EXT_SDRAM_ADDR;
    
    uint32_t start_cycle, end_cycle;
    uint64_t total_dtcm_cycles = 0;
    uint64_t total_sram_cycles = 0;
    uint64_t total_sdram_cycles = 0;
    uint32_t dummy = 0;
    
    // 初始化缓冲区
    for (int i = 0; i < BUFFER_SIZE; i++)
    {
        dtcm_buffer[i] = i;
        sram_buffer[i] = i;
        sdram_buffer[i] = i;
    }
    
    // 测试DTCM读取延迟
    for (int iter = 0; iter < TEST_ITERATIONS; iter++)
    {
        int index = iter % BUFFER_SIZE;
        start_cycle = GetDWT_CycleCount();
        dummy = dtcm_buffer[index];
        end_cycle = GetDWT_CycleCount();
        total_dtcm_cycles += (end_cycle - start_cycle);
    }
    
    // 测试SRAM和SDRAM读取延迟（类似代码）
    // ...
    
    // 计算并输出结果
    double avg_dtcm_cycles = (double)total_dtcm_cycles / TEST_ITERATIONS;
    // ...
}
```

## 4. 调试与测试框架

### 4.1 串口调试控制台

项目实现了基于USART1的调试控制台，支持printf函数重定向：

```c
int fputc(int ch, FILE *f)
{
    while((USART1->ISR&0X40)==0);  // 等待发送完成
    USART1->TDR = (uint8_t) ch;   // 发送数据
    return ch;
}
```

### 4.2 模块化测试开关

项目使用宏定义实现模块化测试开关，便于单独测试各个功能模块：

```c
/*Module Test Switch*/
#define DBG_EXSDRAM_TEST 1
#define DBG_WIFI_TEST 1
#define DBG_QSPIFLASH_TEST 1
//#define DBG_CAMERADCMI_TEST 1
//#define DBG_MICROPHONE_TEST 1
#define DBG_MEMORY_LATENCY_TEST 1
```

## 5. 关键技术特点

### 5.1 内存管理优化

- 使用内存属性定义将不同数据放置在最适合的内存区域
- DTCM用于时间关键数据，提供最低访问延迟
- SRAM用于一般数据存储
- SDRAM用于大容量数据缓存，如图像数据

### 5.2 双核通信机制

使用硬件信号量(HSEM)实现CM7和CM4双核之间的同步和通信：

```c
__HAL_RCC_HSEM_CLK_ENABLE();
HAL_HSEM_FastTake(HSEM_ID_0);
HAL_HSEM_Release(HSEM_ID_0, 0);
```

### 5.3 外设接口抽象

为每个外设模块创建了独立的驱动文件，提供统一的接口，便于维护和扩展：
- sdram_fmc_drv.c - SDRAM驱动
- qspi_flash_drv.c - QSPI Flash驱动
- ov2640_dcmi_drv.c - 摄像头驱动
- microphone_sai_drv.c - 麦克风驱动

## 6. 功能实现总结

SelfBoard项目成功实现了基于STM32H747XIH6的多功能开发板，各个模块通过精心设计的驱动和测试框架实现了可靠的功能：

1. **外部存储扩展**：32MB SDRAM和QSPI Flash提供了充足的存储空间
2. **多媒体采集**：摄像头和麦克风模块支持图像和音频数据采集
3. **网络通信**：WiFi模块支持无线通信功能
4. **性能优化**：通过内存延迟测试和优化，确保系统性能达到最佳
5. **调试支持**：完善的调试控制台和测试框架，便于开发和问题排查

该项目为TinyML应用提供了良好的硬件平台支持，各个功能模块的实现充分考虑了性能、可靠性和易用性。